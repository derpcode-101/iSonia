<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go Programming Crash Course</title>
    <link rel="stylesheet" href="../../styles/lessons.css">
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;600&family=Space+Mono&display=swap" rel="stylesheet">

    <style>

        :root {
            --main: #2345FF;
            --light: rgba(100, 150, 200, 0.3);
            --lighter: rgba(51, 153, 255, 0.08);
            --border: rgba(35, 69, 255);
            --border2: rgba(52, 92, 255, 0.5);
            --med: rgba(52, 92, 255);
            --dark: #1a33cc;
            --img: #2345FF;
        }

        /* Table styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        table th, table td {
            padding: 0.5rem;
            text-align: left;
            border: 1px solid rgba(35, 69, 255, 0.2);
        }

        table th {
            background-color: rgba(35, 69, 255, 0.1);
            color: #2345FF;
            font-family: monospace;
        }

    </style>
</head>
<body>
<!-- Header -->
<header>
    <h1 class="pixel-title">GOLANG</h1>
    <p class="subtitle">A crash course for the GoLang programming language.<br>The fundamentals quick + easy.</p>
</header>

<!-- Dotted line divider -->
<hr class="divider">

<!-- Main content area with margin references -->
<main class="content">
    <!-- Left margin reference -->
    <div class="margin-ref margin-ref-left">GO.000</div>

    <!-- Main content split into text and illustrations -->
    <div class="text-content">
        <div class="text">
            <h1 id="intro">W<span style="font-size: 1.5rem;">hat makes Go stand out from other programming languages?</span></h1>
                Its simplicity, efficiency, and built-in concurrency make it perfectly suited for optimizing programs on modern computing environments.
            <br><br>
            <p>Designed by Google in 2007, Go was created specifically to scale! (aka perfect for parallel programming).<br><br>
                It has the performance comparable to C but has the benefit of more human-readable syntax.</p><br>
            <p>(also the cutest logo ^_^)</p>
        </div>
        <div class="topic">
            <h2 style="font-size: 25px">Go: The Essentials</h2>
                <h3 style="font-size: 18px; margin-bottom: unset; margin-top: 5px">Statically typed</h3> - but with type inference to reduce verbosity
                <h3 style="font-size: 18px; margin-bottom: unset; margin-top: 5px">Garbage collected</h3> - for memory management without manual intervention
                <h3 style="font-size: 18px; margin-bottom: unset; margin-top: 5px">Compiled</h3> - to machine code for efficiency
                <h3 style="font-size: 18px; margin-bottom: unset; margin-top: 5px">Built-in concurrency</h3> - through goroutines and channels
                <h3 style="font-size: 18px; margin-bottom: unset; margin-top: 5px">Fast compilation</h3> - for improved developer productivity
                <h3 style="font-size: 18px; margin-bottom: unset; margin-top: 5px">Standard formatting</h3> - enforced by tools like <code>gofmt</code>
        </div>
    </div>


    <!-- Right margin reference -->
    <div class="margin-ref margin-ref-right">[ 1.0 INTRO ]</div>
</main>

<!-- Table of Contents -->
<div class="toc-container">
    <h2 class="toc-title">Jump to Topic</h2>
    <ul class="toc-list">
        <li class="toc-item"><a href="#syntax" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Basic Syntax</a></li>
        <li class="toc-item"><a href="#data-types" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Data Types</a></li>
        <li class="toc-item"><a href="#functions" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Functions & Methods</a></li>
        <li class="toc-item"><a href="#control-flow" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Control Flow</a></li>
        <li class="toc-item"><a href="#concurrency" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Concurrency</a></li>
        <li class="toc-item"><a href="#modules" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Design Patterns</a></li>
        <li class="toc-item"><a href="#performance" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Project Structure</a></li>
        <li class="toc-item"><a href="#testing" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Testing</a></li>
        <li class="toc-item"><a href="#stdlib" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Standard Library</a></li>

        <li class="toc-item"><a href="#best-practices" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Best Practices</a></li>
        <li class="toc-item"><a href="#performance" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Performance</a></li>
        <li class="toc-item"><a href="#tools" class="toc-link" style="grid-template-columns: repeat(auto-fill, minmax(185px, 1fr));">Tools & Ecosystem</a></li>

    </ul>
</div>

<!-- Main content area with margin references -->
<main class="content">
    <!-- Left margin reference -->
    <div class="margin-ref margin-ref-left">GO.001</div>

    <!-- Main content split into text and illustrations -->
    <div class="text-content">
        <!-- Intro -->
        <div class="text">

            <!-- Setting Up Go -->
            <div class="topic">
                <h2>Setting Up Go</h2>
                <p>Installing Go is straightforward across platforms:</p>
                <pre>

    # Check Go version after installation
                            <code>
        $ go version
        > go version go1.18.3 darwin/amd64
                            </code>
    # Create a new module
                            <code>
        $ mkdir hello
        $ cd hello
        $ go mod init example.com/hello
        $ go run .
                    </code></pre>
            </div>


        </div>
    </div>

    <!-- Right margin reference -->
    <div class="margin-ref margin-ref-right">[ 1.0 INTRO ]</div>
</main>

<!-- Additional content sections -->
<section class="content">
    <div class="margin-ref margin-ref-left">GO.002</div>
    <div class="text-content">
        <div class="text">
            <!--Standard Library Highlights-->
            <div class="topic">
                <h2 id="syntax">Basic Syntax</h2>
                <pre><code>
        package main

        import (
            "fmt"
            "time"
        )
                    </code>
        // This is a comment
        <code>
        func main() {
            fmt.Println("Hello, Go!")

            </code>// Variables<code>
            var age int = 30
            name := "Alice"  </code>// Short declaration<code>

            </code>// Constants<code>
            const MaxConnections = 100

            </code>// Control flow<code>
            if age > 18 {
                fmt.Println(name, "is an adult")
            }

            </code>// Loops<code>
            for i := 0; i < 5; i++ {
                fmt.Println(i)
            }

            </code>// While-style loop<code>
            count := 0
            for count < 5 {
                count++
            }
        }
            </code></pre>
            </div>
            <div class="illustration">
                <!-- SVG illustration for Go's gopher mascot in blue -->
                <svg width="300" height="400" class="svg-illustration">
                    <!-- Simplified Gopher -->
                    <ellipse cx="150" cy="180" rx="100" ry="90" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>

                    <!-- Head -->
                    <ellipse cx="150" cy="120" rx="70" ry="60" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>

                    <!-- Eyes -->
                    <circle cx="125" cy="105" r="10" fill="white" stroke="#2345FF" stroke-width="2"/>
                    <circle cx="175" cy="105" r="10" fill="white" stroke="#2345FF" stroke-width="2"/>
                    <circle cx="125" cy="105" r="5" fill="#2345FF"/>
                    <circle cx="175" cy="105" r="5" fill="#2345FF"/>

                    <!-- Ears -->
                    <ellipse cx="100" cy="70" rx="15" ry="25" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                    <ellipse cx="200" cy="70" rx="15" ry="25" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>

                    <!-- Nose -->
                    <ellipse cx="150" cy="130" rx="15" ry="10" fill="#2345FF"/>

                    <!-- Smile -->
                    <path d="M 120 140 Q 150 160 180 140" fill="none" stroke="#2345FF" stroke-width="2"/>

                    <!-- Feet -->
                    <ellipse cx="120" cy="270" rx="20" ry="10" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                    <ellipse cx="180" cy="270" rx="20" ry="10" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>

                    <!-- Arms -->
                    <path d="M 70 180 Q 50 220 70 240" fill="none" stroke="#2345FF" stroke-width="2"/>
                    <path d="M 230 180 Q 250 220 230 240" fill="none" stroke="#2345FF" stroke-width="2"/>

                </svg>

                <div style="margin-top: 2rem;">
                    <table>
                        <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Goroutines</td>
                            <td>Lightweight threads managed by the Go runtime</td>
                        </tr>
                        <tr>
                            <td>Channels</td>
                            <td>Typed conduits for sending and receiving values</td>
                        </tr>
                        <tr>
                            <td>Interfaces</td>
                            <td>Implicit implementation for flexibility</td>
                        </tr>
                        <tr>
                            <td>Defer</td>
                            <td>Execution of functions at the end of the current scope</td>
                        </tr>
                        <tr>
                            <td>Error handling</td>
                            <td>Explicit error values rather than exceptions</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <!-- Data Types & Structures -->
            <div class="topic">
                <h2 id="data-types">Data Types & Structures</h2>

                <h3>Basic Types</h3>
                <pre>
                    <code>
        </code>// Numeric types<code>
        var i int = 42
        var f float64 = 3.14
        var c complex128 = 1 + 2i

        </code>// String and boolean<code>
        var s string = "hello"
        var b bool = true

        </code>// Zero values<code>
        var z int      </code>// zero value: 0<code>
        var z2 string  </code>// zero value: ""<code>
        var z3 bool    </code>// zero value: false<code>
                </code></pre>

                <h3>Composite Types</h3>
                <pre>
                    <code>
        </code>// Arrays - fixed size<code>
        var arr [5]int = [5]int{1, 2, 3, 4, 5}

        </code>// or with type inference<code>
        arr2 := [3]string{"a", "b", "c"}

        </code>// Slices - dynamic size<code>
        slice := []int{1, 2, 3}
        slice = append(slice, 4, 5)

        </code>// Maps - key-value pairs<code>
        m := make(map[string]int)
        m["one"] = 1
        m["two"] = 2

        </code>// Checking for existence<code>
        value, exists := m["three"]
        if !exists {
            fmt.Println("Key does not exist")
        }

        </code>// Structs - composite types<code>
        type Person struct {
            Name string
            Age  int
        }

        p := Person{Name: "Alice", Age: 30}
        fmt.Println(p.Name) </code>// Access field with dot notation<code>
            </code></pre>

            </div>
            <!-- Functions & Methods -->
            <div class="topic">
                <h2 id="functions">Functions & Methods</h2>
                            <pre>

        // Basic function<code>
        func add(a, b int) int {
            return a + b
        }

        </code>// Multiple return values<code>
        func divide(a, b float64) (float64, error) {
            if b == 0 {
                return 0, errors.New("division by zero")
            }
            return a / b, nil
        }

        </code>// Variadic function<code>
        func sum(nums ...int) int {
            total := 0
            for _, num := range nums {
                total += num
            }
            return total
        }

        </code>// Methods (functions attached to types)<code>
        type Rectangle struct {
            Width, Height float64
        }

        </code>// Method with receiver<code>
        func (r Rectangle) Area() float64 {
            return r.Width * r.Height
        }

        </code>// Method with pointer receiver (can modify the receiver)<code>
        func (r *Rectangle) Scale(factor float64) {
            r.Width *= factor
            r.Height *= factor
        }
            </code></pre>
            </div>
            <!-- Control Flow -->
            <div class="topic">
                <h2 id="control-flow">Control Flow</h2>
                <h3>Conditional Statements</h3>
                <pre>

            // If statement<code>
            if x > 10 {
                fmt.Println("x is greater than 10")
            } else if x < 0 {
                fmt.Println("x is negative")
            } else {
                fmt.Println("x is between 0 and 10")
            }

            </code>// If with short statement<code>
            if err := doSomething(); err != nil {
                fmt.Println("Error:", err)
            }

            </code>// Switch statement<code>
            switch os := runtime.GOOS; os {
            case "darwin":
                fmt.Println("OS X.")
            case "linux":
                fmt.Println("Linux.")
            default:
                fmt.Printf("%s.\n", os)
            }

            </code>// Switch without expression (like if-else)<code>
            switch {
            case t.Hour() < 12:
                fmt.Println("Good morning!")
            case t.Hour() < 17:
                fmt.Println("Good afternoon!")
            default:
                fmt.Println("Good evening!")
            }
            </code></pre>

            <h3>Loops</h3>
            <pre>

            // Basic for loop<code>
            for i := 0; i < 10; i++ {
                fmt.Println(i)
            }

            </code>// For as a while loop<code>
            i := 0
            for i < 10 {
                i++
            }

            </code>// Infinite loop with break<code>
            for {
                </code>// Do something repeatedly<code>
                if condition {
                    break </code>// Exit the loop<code>
                }
                if otherCondition {
                    continue </code>// Skip to the next iteration<code>
                }
            }

            </code>// Range loop for slices, arrays, maps, strings<code>
            names := []string{"Alice", "Bob", "Charlie"}
            for i, name := range names {
                fmt.Printf("%d: %s\n", i, name)
            }

            </code>// Range with maps<code>
            for key, value := range m {
                fmt.Printf("%s: %d\n", key, value)
            }
                </code></pre>
            </div>
            <!-- Error Handling -->
            <div class="topic">
                <h2 id="error-handling">Error Handling</h2>
                <p>Go uses explicit error values rather than exceptions:</p>
                <pre>

            // Function returning an error<code>
            func OpenFile(name string) (*File, error) {
                if fileNotExist(name) {
                    return nil, errors.New("file does not exist")
                }
                </code>// Open the file and return it<code>
                return file, nil
            }

            </code>// Using a function that may return an error<code>
            f, err := OpenFile("data.txt")
            if err != nil {
                </code>// Handle error<code>
                fmt.Println("Error:", err)
                return
            }

            </code>// Use the file<code>
            defer f.Close() </code>// Called when surrounding function returns
                </pre>

                <h3>Creating Custom Errors</h3>
                <pre>

            // Custom error type<code>
            type MyError struct {
                Code    int
                Message string
            }

            </code>// Implement the error interface<code>
            func (e *MyError) Error() string {
                return fmt.Sprintf("%d: %s", e.Code, e.Message)
            }

            </code>// Return custom error<code>
            func doSomething() error {
                return &MyError{
                    Code:    500,
                    Message: "something went wrong",
                }
            }
                </code></pre>
            </div>
        </div>
    </div>
    <div class="margin-ref margin-ref-right">[ 2.0 BASICS ]</div>
</section>
<section class="content">
    <div class="margin-ref margin-ref-left">GO.003</div>
    <div class="text-content">
        <div class="text">
            <!-- Concurrency with Goroutines -->
            <div class="topic">
                <h2 id="concurrency">Concurrency with Goroutines</h2>
                <p>Go's lightweight threads, called goroutines, enable concurrent programming patterns with minimal overhead:</p>

                <pre>
                    <code>
        func main() {

            </code>// Start a goroutine<code>
            go sayHello("world")

            </code>// Main goroutine continues execution<code>
            fmt.Println("Hello from main")

            </code>// Wait for goroutines to finish<code>
            time.Sleep(100 * time.Millisecond)

        }

        func sayHello(name string) {
            fmt.Println("Hello,", name)
        }
        </code></pre>
                <div class="illustration">
                    <!-- SVG illustration for Goroutines and Channels -->
                    <svg width="400" height="350" class="svg-illustration">
                        <!-- Main components -->
                        <rect x="50" y="50" width="300" height="250" rx="10" fill="none" stroke="#2345FF" stroke-width="1"/>
                        <text x="160" y="30" class="component-label">GO CONCURRENCY</text>

                        <!-- Goroutines -->
                        <circle cx="100" cy="100" r="25" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                        <circle cx="170" cy="100" r="25" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                        <circle cx="240" cy="100" r="25" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                        <circle cx="310" cy="100" r="25" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>

                        <text x="100" y="105" font-family="monospace" fill="#2345FF" font-size="12" text-anchor="middle">G1</text>
                        <text x="170" y="105" font-family="monospace" fill="#2345FF" font-size="12" text-anchor="middle">G2</text>
                        <text x="240" y="105" font-family="monospace" fill="#2345FF" font-size="12" text-anchor="middle">G3</text>
                        <text x="310" y="105" font-family="monospace" fill="#2345FF" font-size="12" text-anchor="middle">G4</text>

                        <!-- Channels -->
                        <rect x="70" y="170" width="260" height="30" rx="15" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                        <text x="200" y="190" font-family="monospace" fill="#2345FF" font-size="12" text-anchor="middle">CHANNEL</text>

                        <!-- Buffer elements in channel -->
                        <circle cx="110" cy="185" r="10" fill="#2345FF"/>
                        <circle cx="150" cy="185" r="10" fill="#2345FF"/>
                        <circle cx="190" cy="185" r="10" fill="#2345FF"/>
                        <circle cx="230" cy="185" r="10" stroke="#2345FF" stroke-width="1" fill="none"/>
                        <circle cx="270" cy="185" r="10" stroke="#2345FF" stroke-width="1" fill="none"/>

                        <!-- Connection arrows -->
                        <line x1="100" y1="125" x2="100" y2="170" stroke="#2345FF" stroke-width="1.5" stroke-dasharray="5,2"/>
                        <polygon points="100,170 97,165 103,165" fill="#2345FF"/>

                        <line x1="170" y1="125" x2="170" y2="170" stroke="#2345FF" stroke-width="1.5" stroke-dasharray="5,2"/>
                        <polygon points="170,170 167,165 173,165" fill="#2345FF"/>

                        <line x1="240" y1="125" x2="240" y2="170" stroke="#2345FF" stroke-width="1.5" stroke-dasharray="5,2"/>
                        <polygon points="240,170 237,165 243,165" fill="#2345FF"/>

                        <line x1="310" y1="125" x2="310" y2="170" stroke="#2345FF" stroke-width="1.5" stroke-dasharray="5,2"/>
                        <polygon points="310,170 307,165 313,165" fill="#2345FF"/>

                        <!-- Main Goroutine -->
                        <rect x="140" y="240" width="120" height="40" rx="5" class="svg-fill-light" stroke="#2345FF" stroke-width="2"/>
                        <text x="200" y="265" font-family="monospace" fill="#2345FF" font-size="12" text-anchor="middle">MAIN</text>

                        <line x1="200" y1="200" x2="200" y2="240" stroke="#2345FF" stroke-width="1.5"/>
                        <polygon points="200,240 197,235 203,235" fill="#2345FF"/>

                        <!-- Labels -->
                        <text x="80" y="75" class="component-label">GOROUTINES</text>
                        <text x="340" y="185" class="component-label">BUFFERED CHANNEL</text>
                    </svg>
                </div>
                <h3>WaitGroups for Synchronization</h3>
                <pre>

        <code>func main() {
            var wg sync.WaitGroup

            </code>// Launch 5 goroutines<code>
            for i := 0; i < 5; i++ {
                wg.Add(1) </code>// Increment counter<code>
                go func(id int) {
                    defer wg.Done() </code>// Decrement counter when done<code>
                    fmt.Printf("Worker %d done\n", id)
                }(i)
            }

            </code>// Wait for all goroutines to finish<code>
            wg.Wait()
            fmt.Println("All workers done")
        }

</code></pre>
            </div>
            <!-- Channels -->
            <div class="topic">
                <h2 id="channels">Channels</h2>
                <p>Channels provide a mechanism for goroutines to communicate and synchronize:</p>

                <pre>

    <code>func main() {
        </code>// Create a channel<code>
        ch := make(chan string)

        </code>// Send data on channel in a goroutine<code>
        go func() {
            ch <- "Hello from goroutine"
        }()

        </code>// Receive from channel (blocks until data is available)<code>
        msg := <-ch
        fmt.Println(msg)

        </code>// Buffered channels<code>
        buffer := make(chan int, 3) </code>// Can hold 3 ints<code>
        buffer <- 1
        buffer <- 2
        buffer <- 3
        </code>// Now buffer is full, next send would block<code>

        fmt.Println(<-buffer) // 1
        fmt.Println(<-buffer) // 2
        fmt.Println(<-buffer) // 3
    }

</code></pre>

                <h3>Selecting from Multiple Channels</h3>
                <pre>

    <code>func main() {

        ch1 := make(chan string)
        ch2 := make(chan string)

        </code>// Send on ch1 after 1 second<code>
        go func() {
            time.Sleep(1 * time.Second)
            ch1 <- "one"
        }()

        </code>// Send on ch2 after 2 seconds<code>
        go func() {
            time.Sleep(2 * time.Second)
            ch2 <- "two"
        }()

        </code>// Select blocks until one of its cases can proceed<code>
        for i := 0; i < 2; i++ {
            select {
            case msg1 := <-ch1:
                fmt.Println("Received", msg1)
            case msg2 := <-ch2:
                fmt.Println("Received", msg2)
            case <-time.After(3 * time.Second):
                fmt.Println("Timeout")
                return
            }
        }
    }

</code></pre>

                <h3>Concurrency Patterns: Fan-Out, Fan-In</h3>
                <p>Distribute work across multiple goroutines and collect the results:</p>
                <pre>

    <code>func main() {

        </code>// Generate work<code>
        jobs := make(chan int, 100)
        results := make(chan int, 100)

        </code>// Start 3 workers (fan-out)<code>
        for w := 1; w <= 3; w++ {
            go worker(w, jobs, results)
        }

        </code>// Send jobs<code>
        for j := 1; j <= 9; j++ {
            jobs <- j
        }
        close(jobs)

        </code>// Collect results (fan-in)<code>
        for a := 1; a <= 9; a++ {
            <-results
        }
    }

    func worker(id int, jobs <-chan int, results chan<- int) {
        for j := range jobs {
            fmt.Printf("Worker %d processing job %d\n", id, j)
            time.Sleep(time.Second)
            results <- j * 2
        }
    }

</code></pre>
            </div>
        </div>
    </div>
    <div class="margin-ref margin-ref-right">[ 3.0 CONCURRENCY ]</div>
</section>

<section class="content">
    <div class="margin-ref margin-ref-left">GO.004</div>
    <div class="text-content">
        <div class="text">
            <!-- Interfaces -->
            <div class="topic">
                <h2 id="interfaces">Interfaces</h2>
                <p>Interfaces define behavior without prescribing implementation:</p>

                <pre>

        // Interface definition<code>
        type Reader interface {
            Read(p []byte) (n int, err error)
        }

        type Writer interface {
            Write(p []byte) (n int, err error)
        }

        </code>// Composition of interfaces<code>
        type ReadWriter interface {
            Reader
            Writer
        }

        </code>// Implementing an interface<code>
        type File struct {
            </code>// ...<code>
        }

        </code>// File implements Reader interface<code>
        func (f *File) Read(p []byte) (n int, err error) {
            </code>// Implementation here<code>
            return len(p), nil
        }

        </code>// File implements Writer interface<code>
        func (f *File) Write(p []byte) (n int, err error) {
            </code>// Implementation here<code>
            return len(p), nil
        }

        </code>// Using an interface<code>
        func Copy(dst Writer, src Reader) error {
            </code>// Any type that implements these interfaces can be used
            // ...<code>
        }

</code></pre>

                <h3>The Empty Interface</h3>
                <pre>

        // Empty interface can hold any value<code>
        var i interface{}
        i = 42
        i = "hello"
        i = struct{ Name string }{"Alice"}

        </code>// Type assertions<code>
        s, ok := i.(string)
        if !ok {
            fmt.Println("i is not a string")
        }

        </code>// Type switches<code>
        switch v := i.(type) {
        case int:
            fmt.Println("i is an int:", v)
        case string:
            fmt.Println("i is a string:", v)
        default:
            fmt.Println("unknown type")
        }

</code></pre>
            </div>
            <!-- Project Structure & Modules -->
            <div class="topic">
                <h2 id="modules">Project Structure & Modules</h2>
        <p>Go code is organized into packages and modules:</p>

        <h3>Packages</h3>
        <pre>

        // File: math/calculation.go<code>
        package math

        </code>// Exported function (starts with uppercase)<code>
        func Add(a, b int) int {
            return a + b
        }

        </code>// Unexported function (starts with lowercase)<code>
        func multiply(a, b int) int {
            return a * b
        }

</code>
        </pre>

        <h3>Importing Packages</h3>
        <pre>

        <code>package main

        import (
            "fmt"
            "example.com/myproject/math"
        )

        func main() {
            result := math.Add(5, 3)
            fmt.Println(result) // 8

            </code>// math.multiply(5, 3) // Error: unexported<code>
        }

</code></pre>

        <h3>Go Modules</h3>
        <pre>

        // Initialize a new module<code>
        $ go mod init example.com/myproject

        </code>// Add a dependency<code>
        $ go get github.com/pkg/errors

        </code>// Update dependencies<code>
        $ go get -u

        </code>// Tidy dependencies (add missing, remove unused)<code>
        $ go mod tidy

</code></pre>
    </div>
            <!-- Testing -->
            <div class="topic">
                <h2 id="testing">Testing</h2>
            <p>Go includes built-in support for testing:</p>

            <h3>Writing Tests</h3>
            <pre>

        // File: math/calculation_test.go<code>
        package math

        import "testing"

        func TestAdd(t *testing.T) {
            got := Add(2, 3)
            want := 5

            if got != want {
                t.Errorf("Add(2, 3) = %d; want %d", got, want)
            }
        }

        </code>// Table-driven tests<code>
        func TestMultiply(t *testing.T) {
            tests := []struct {
                a, b, want int
            }{
                {2, 3, 6},
                {-1, 5, -5},
                {0, 10, 0},
            }

            for _, tc := range tests {
                got := multiply(tc.a, tc.b)
                if got != tc.want {
                    t.Errorf("multiply(%d, %d) = %d; want %d",
                             tc.a, tc.b, got, tc.want)
                }
            }
        }

</code></pre>

            <h3>Running Tests</h3>
            <pre>

        // Run all tests<code>
        $ go test ./...

        </code>// Run tests with verbose output<code>
        $ go test -v

        </code>// Run a specific test<code>
        $ go test -run TestAdd

        </code>// Run benchmark tests<code>
        $ go test -bench=.

        </code>// Check test coverage<code>
        $ go test -cover

</code></pre>
        </div>
            <!-- Standard Library Highlights -->
            <div class="topic">
                <h2 id="stdlib">Standard Library Highlights</h2>
            <p>Go has a rich standard library that covers most common needs:</p>

            <ul>
                <li><code>fmt</code> - Formatted I/O with functions like Printf</li>
                <li><code>io</code> - Basic I/O interfaces</li>
                <li><code>os</code> - Platform-independent OS functionality</li>
                <li><code>strings</code> - String manipulation functions</li>
                <li><code>time</code> - Time and duration functionality</li>
                <li><code>net/http</code> - HTTP client and server implementations</li>
                <li><code>encoding/json</code> - JSON encoding and decoding</li>
                <li><code>sync</code> - Synchronization primitives</li>
                <li><code>context</code> - Package for managing deadlines, cancellations, etc.</li>
            </ul>

            <h3>HTTP Server Example</h3>
            <pre>

        <code>package main

        import (
            "fmt"
            "log"
            "net/http"
        )

        func handler(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])
        }

        func main() {
            http.HandleFunc("/", handler)
            log.Println("Server starting on port 8080...")
            log.Fatal(http.ListenAndServe(":8080", nil))
        }

</code></pre>
        </div>
        </div>
    </div>
    <div class="margin-ref margin-ref-right">[ 4.0 PACKAGES ]</div>
</section>

<section class="content">
    <div class="margin-ref margin-ref-left">GO.005</div>
    <div class="text-content">
        <div class="text">
            <!-- Best Practices -->
            <div class="topic">
                <h2 id="best-practices">Best Practices</h2>

                <h3>Error Handling</h3>
                <ul>
                    <li>Check errors immediately after function calls that return them</li>
                    <li>Wrap errors with context using packages like <code>github.com/pkg/errors</code></li>
                    <li>Don't use panic for regular error handling</li>
                </ul>

                <h3>Code Organization</h3>
                <ul>
                    <li>Group related code into packages based on functionality</li>
                    <li>Follow Go's standard project layout where appropriate</li>
                    <li>Avoid deeply nested package hierarchies</li>
                </ul>

                <h3>Naming Conventions</h3>
                <ul>
                    <li>Package names: short, concise nouns (e.g., <code>time</code>, <code>http</code>)</li>
                    <li>Function and variable names: camelCase for unexported, PascalCase for exported</li>
                    <li>Interface names: often end with -er (e.g., <code>Reader</code>, <code>Writer</code>)</li>
                    <li>Use meaningful but concise names; abbreviate judiciously</li>
                </ul>
            </div>
            <!-- Performance Tips -->
            <div class="topic">
                <h2 id="performance">Performance Tips</h2>

                <h3>Memory Management</h3>
                <ul>
                    <li>Preallocate slices and maps when you know the approximate size</li>
                    <li>Reuse memory with <code>sync.Pool</code> for frequently allocated objects</li>
                    <li>Be aware of heap allocations vs. stack allocations</li>
                </ul>

                <h3>Concurrency</h3>
                <ul>
                    <li>Don't overuse goroutines; they're lightweight but not free</li>
                    <li>Use buffered channels appropriately</li>
                    <li>Profile and benchmark to identify bottlenecks</li>
                    <li>Consider the <code>context</code> package for timeouts and cancellation</li>
                </ul>

                <pre>

        // Example of a context with timeout<code>
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel() // Always call cancel to release resources

        </code>// Use ctx in HTTP requests, database calls, etc.<code>
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)

</code></pre>
            </div>
        </div>
    </div>
</section>
<section class="content">
    <div class="margin-ref margin-ref-left">GO.005</div>
    <div class="text-content">
        <div class="text">
            <!-- Tools & Ecosystem -->
            <div class="topic">
                <h2 id="tools">Tools & Ecosystem</h2>

                <h3>Essential Tools</h3>
                <ul>
                    <li><code>go fmt</code> - Format code according to Go standards</li>
                    <li><code>go vet</code> - Find potential issues in code</li>
                    <li><code>go test</code> - Run tests and benchmarks</li>
                    <li><code>go build</code> - Compile packages and dependencies</li>
                    <li><code>go run</code> - Compile and run a Go program</li>
                    <li><code>go mod</code> - Module maintenance</li>
                </ul>

                <h3>Popular Packages</h3>
                <ul>
                    <li><strong>Web frameworks:</strong> Gin, Echo, Fiber</li>
                    <li><strong>Database:</strong> GORM, sqlx, pgx</li>
                    <li><strong>CLI apps:</strong> Cobra, Viper</li>
                    <li><strong>Testing:</strong> Testify, GoMock</li>
                    <li><strong>Logging:</strong> Zap, Logrus</li>
                    <li><strong>Configuration:</strong> Viper</li>
                </ul>
            </div>
            <!-- Conclusion -->
            <div class="topic">
                <h2 id="conclusion">Conclusion</h2>
                <p>Go excels at building reliable, efficient systems with minimal complexity. Its approach to concurrency through goroutines and channels enables developers to write highly concurrent code without the traditional challenges of thread management.</p>

                <p>The language's focus on simplicity, consistency, and practicality has made it popular for a wide range of applications, from cloud services and CLI tools to web applications and microservices.</p>

                <p>By embracing Go's idioms and best practices, you'll find that the language encourages a style of programming that is both productive and produces robust, maintainable code.</p>

                <h3>Further Learning Resources</h3>
                <ul>
                    <li><a href="https://go.dev/doc/" style="color: #2345FF; text-decoration: none;">Official Go Documentation</a></li>
                    <li><a href="https://go.dev/tour/" style="color: #2345FF; text-decoration: none;">A Tour of Go</a></li>
                    <li><a href="https://go.dev/blog/" style="color: #2345FF; text-decoration: none;">The Go Blog</a></li>
                    <li><a href="https://github.com/golang/go/wiki" style="color: #2345FF; text-decoration: none;">Go Wiki</a></li>
                    <li>"The Go Programming Language" by Alan A. A. Donovan and Brian W. Kernighan –
                        <a href="https://www.gopl.io/" target="_blank"
                           style="color: crimson; text-decoration: none;">Read Here</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div class="margin-ref margin-ref-right">[ 5.0 PRACTICES ]</div>
</section>
<!-- Back to Top Button -->
<a href="#" class="back-to-top">Back to Top</a>
</body>
</html>